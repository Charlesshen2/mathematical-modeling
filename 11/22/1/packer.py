{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ./constants.ipynb\n",
    "%run ./auxiliary_methods.ipynb\n",
    "%run ./item.ipynb\n",
    "%run ./bin.ipynb"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Packer:\n",
    "    def __init__(self):\n",
    "        self.bins = [] \n",
    "        self.unplaced_items = []\n",
    "        self.placed_items = []\n",
    "        self.unfit_items = []\n",
    "        self.total_items = 0\n",
    "        self.total_used_bins = 0 # not used yet\n",
    "        self.used_bins = [] # not used yet\n",
    "    \n",
    "    def add_bin(self, bin):\n",
    "        return self.bins.append(bin)\n",
    "    \n",
    "    def add_item(self, item): \n",
    "        \"\"\"Add unplaced items into bin's unplaced_items list.\n",
    "        Args:\n",
    "            item: an unplaced item.\n",
    "        Returns:\n",
    "            The unplaced item is added into bin's unplaced_items list.\"\"\"\n",
    "        \n",
    "        self.total_items += 1\n",
    "        return self.unplaced_items.append(item) \n",
    "    \n",
    "    def pivot_dict(self, bin, item):\n",
    "        \"\"\"For each item to be placed into a certain bin, obtain a corresponding comparison parameter of each optional pivot that the item can be placed.\n",
    "        Args:\n",
    "            bin: a bin in bin list that a certain item will be placed into.\n",
    "            item: an unplaced item in item list.\n",
    "        Returns:\n",
    "            a pivot_dict contain all optional pivot point and their comparison parameter of the item.\n",
    "            a empty dict may be returned if the item couldn't be placed into the bin.\n",
    "        \"\"\"\n",
    "        \n",
    "        pivot_dict = {}\n",
    "        can_put = False\n",
    "        \n",
    "        for axis in range(0, 3): \n",
    "            items_in_bin = bin.items \n",
    "            items_in_bin_temp = items_in_bin[:] \n",
    "            \n",
    "            n = 0\n",
    "            while n < len(items_in_bin):\n",
    "                pivot = [0, 0, 0] \n",
    "                \n",
    "                if axis == Axis.LENGTH: # axis = 0/ x-axis\n",
    "                    ib = items_in_bin[n]\n",
    "                    pivot = [ib.position[0] + ib.get_dimension()[0],\n",
    "                            ib.position[1],\n",
    "                            ib.position[2]]\n",
    "                    try_put_item = bin.can_hold_item_with_rotation(item, pivot) \n",
    "                    \n",
    "                    if try_put_item: \n",
    "                        can_put = True\n",
    "                        q = 0\n",
    "                        q = 0\n",
    "                        ib_neigh_x_axis = []\n",
    "                        ib_neigh_y_axis = []\n",
    "                        ib_neigh_z_axis = []\n",
    "                        right_neighbor = False\n",
    "                        front_neighbor = False\n",
    "                        above_neighbor = False\n",
    "                        \n",
    "                        while q < len(items_in_bin_temp):\n",
    "                            if items_in_bin_temp[q] == items_in_bin[n]: \n",
    "                                q += 1 \n",
    "                            \n",
    "                            else:\n",
    "                                ib_neighbor = items_in_bin_temp[q]\n",
    "                                \n",
    "                                if (\n",
    "                                    ib_neighbor.position[0] > ib.position[0] + ib.get_dimension()[0] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] \n",
    "                                ): \n",
    "                                    right_neighbor = True\n",
    "                                    x_distance = ib_neighbor.position[0] - (ib.position[0] + ib.get_dimension()[0])\n",
    "                                    ib_neigh_x_axis.append(x_distance)\n",
    "                                    \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[1] >= ib.position[1] + ib.get_dimension()[1] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] + ib.get_dimension()[0] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] \n",
    "                                ):\n",
    "                                    front_neighbor = True\n",
    "                                    y_distance = ib_neighbor.position[1] - ib.position[1]\n",
    "                                    ib_neigh_y_axis.append(y_distance)\n",
    "                                \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[2] >= ib.position[2] + ib.get_dimension()[2] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] + ib.get_dimension()[0] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] \n",
    "                                ):\n",
    "                                    above_neighbor = True\n",
    "                                    z_distance = ib_neighbor.position[2] - ib.position[2]\n",
    "                                    ib_neigh_z_axis.append(z_distance)\n",
    "                                \n",
    "                                q += 1 \n",
    "                                \n",
    "                        if not right_neighbor: \n",
    "                            x_distance = bin.length - (ib.position[0] + ib.get_dimension()[0])\n",
    "                            ib_neigh_x_axis.append(x_distance)\n",
    "                        \n",
    "                        if not front_neighbor: \n",
    "                            y_distance = bin.width - ib.position[1]\n",
    "                            ib_neigh_y_axis.append(y_distance)\n",
    "                        \n",
    "                        if not above_neighbor: \n",
    "                            z_distance = bin.height - ib.position[2]\n",
    "                            ib_neigh_z_axis.append(z_distance)\n",
    "                        \n",
    "                        distance_3D = [min(ib_neigh_x_axis), min(ib_neigh_y_axis), min(ib_neigh_z_axis)]\n",
    "                        pivot_dict[tuple(pivot)] = distance_3D\n",
    "                \n",
    "                elif axis == Axis.WIDTH: # axis = 1/ y-axis\n",
    "                    ib = items_in_bin[n]\n",
    "                    pivot = [ib.position[0],\n",
    "                            ib.position[1] + ib.get_dimension()[1],\n",
    "                            ib.position[2]]\n",
    "                    try_put_item = bin.can_hold_item_with_rotation(item, pivot) \n",
    "                    \n",
    "                    if try_put_item: \n",
    "                        can_put = True\n",
    "                        q = 0\n",
    "                        ib_neigh_x_axis = []\n",
    "                        ib_neigh_y_axis = []\n",
    "                        ib_neigh_z_axis = []\n",
    "                        right_neighbor = False\n",
    "                        front_neighbor = False\n",
    "                        above_neighbor = False\n",
    "                        \n",
    "                        while q < len(items_in_bin_temp):\n",
    "                            if items_in_bin_temp[q] == items_in_bin[n]: \n",
    "                                q += 1 \n",
    "                            \n",
    "                            else:\n",
    "                                ib_neighbor = items_in_bin_temp[q]\n",
    "                                \n",
    "                                if (\n",
    "                                    ib_neighbor.position[0] >= ib.position[0] + ib.get_dimension()[0] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] + ib.get_dimension()[1] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] \n",
    "                                ):\n",
    "                                    right_neighbor = True\n",
    "                                    x_distance = ib_neighbor.position[0] - ib.position[0]\n",
    "                                    ib_neigh_x_axis.append(x_distance)\n",
    "                                \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[1] > ib.position[1] + ib.get_dimension()[1] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] \n",
    "                                ):\n",
    "                                    front_neighbor = True\n",
    "                                    y_distance = ib_neighbor.position[1] - (ib.position[1] + ib.get_dimension()[1])\n",
    "                                    ib_neigh_y_axis.append(y_distance)\n",
    "                                \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[2] >= ib.position[2] + ib.get_dimension()[2] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] + ib.get_dimension()[1] \n",
    "                                ):\n",
    "                                    above_neighbor = True\n",
    "                                    z_distance = ib_neighbor.position[2] - ib.position[2]\n",
    "                                    ib_neigh_z_axis.append(z_distance)\n",
    "                                \n",
    "                                q += 1\n",
    "                        \n",
    "                        if not right_neighbor: \n",
    "                            x_distance = bin.length - ib.position[0]\n",
    "                            ib_neigh_x_axis.append(x_distance)\n",
    "                        \n",
    "                        if not front_neighbor: \n",
    "                            y_distance = bin.width - (ib.position[1] + ib.get_dimension()[1])\n",
    "                            ib_neigh_y_axis.append(y_distance)\n",
    "                        \n",
    "                        if not above_neighbor: \n",
    "                            z_distance = bin.height - ib.position[2]\n",
    "                            ib_neigh_z_axis.append(z_distance)\n",
    "                        \n",
    "                        distance_3D = [min(ib_neigh_x_axis), min(ib_neigh_y_axis), min(ib_neigh_z_axis)]\n",
    "                        pivot_dict[tuple(pivot)] = distance_3D\n",
    "            \n",
    "                elif axis == Axis.HEIGHT: # axis = 2/ z-axis\n",
    "                    ib = items_in_bin[n]\n",
    "                    pivot = [ib.position[0],\n",
    "                            ib.position[1],\n",
    "                            ib.position[2] + ib.get_dimension()[2]]\n",
    "                    try_put_item = bin.can_hold_item_with_rotation(item, pivot) \n",
    "                    \n",
    "                    if try_put_item: \n",
    "                        can_put = True\n",
    "                        q = 0\n",
    "                        ib_neigh_x_axis = []\n",
    "                        ib_neigh_y_axis = []\n",
    "                        ib_neigh_z_axis = []\n",
    "                        right_neighbor = False\n",
    "                        front_neighbor = False\n",
    "                        above_neighbor = False\n",
    "                        \n",
    "                        while q < len(items_in_bin_temp):\n",
    "                            if items_in_bin_temp[q] == items_in_bin[n]: \n",
    "                                q += 1 \n",
    "                            \n",
    "                            else:\n",
    "                                ib_neighbor = items_in_bin_temp[q]\n",
    "                                \n",
    "                                if (\n",
    "                                    ib_neighbor.position[0] >= ib.position[0] + ib.get_dimension()[0] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] + ib.get_dimension()[2] \n",
    "                                ):\n",
    "                                    right_neighbor = True\n",
    "                                    x_distance = ib_neighbor.position[0] - ib.position[0]\n",
    "                                    ib_neigh_x_axis.append(x_distance)\n",
    "                                \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[1] > ib.position[1] + ib.get_dimension()[1] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] and \n",
    "                                    ib_neighbor.position[2] + ib_neighbor.get_dimension()[2] > ib.position[2] + ib.get_dimension()[2] \n",
    "                                ):\n",
    "                                    front_neighbor = True\n",
    "                                    y_distance = ib_neighbor.position[1] - (ib.position[1] + ib.get_dimension()[1])\n",
    "                                    ib_neigh_y_axis.append(y_distance)\n",
    "                                \n",
    "                                elif (\n",
    "                                    ib_neighbor.position[2] >= ib.position[2] + ib.get_dimension()[2] and \n",
    "                                    ib_neighbor.position[1] + ib_neighbor.get_dimension()[1] > ib.position[1] and \n",
    "                                    ib_neighbor.position[0] + ib_neighbor.get_dimension()[0] > ib.position[0] \n",
    "                                ):\n",
    "                                    above_neighbor = True\n",
    "                                    z_distance = ib_neighbor.position[2] - ib.position[2]\n",
    "                                    ib_neigh_z_axis.append(z_distance)\n",
    "                                \n",
    "                                q += 1\n",
    "                                \n",
    "                        if not right_neighbor: \n",
    "                            x_distance = bin.length - ib.position[0]\n",
    "                            ib_neigh_x_axis.append(x_distance)\n",
    "                        \n",
    "                        if not front_neighbor: \n",
    "                            y_distance = bin.width - ib.position[1]\n",
    "                            ib_neigh_y_axis.append(y_distance)\n",
    "                        \n",
    "                        if not above_neighbor: \n",
    "                            z_distance = bin.height - (ib.position[2] + ib.get_dimension()[2])\n",
    "                            ib_neigh_z_axis.append(z_distance)\n",
    "                        \n",
    "                        distance_3D = [min(ib_neigh_x_axis), min(ib_neigh_y_axis), min(ib_neigh_z_axis)]\n",
    "                        pivot_dict[tuple(pivot)] = distance_3D\n",
    "                \n",
    "                n += 1\n",
    "        \n",
    "        return pivot_dict\n",
    "    \n",
    "    def pivot_list(self, bin, item):\n",
    "        \"\"\"Obtain all optional pivot points that one item could be placed into a certain bin.\n",
    "        Args:\n",
    "            bin: a bin in bin list that a certain item will be placed into.\n",
    "            item: an unplaced item in item list.\n",
    "        Returns:\n",
    "            a pivot_list containing all optional pivot points that the item could be placed into a certain bin.\n",
    "        \"\"\"\n",
    "        \n",
    "        pivot_list = [] \n",
    "        \n",
    "        for axis in range(0, 3): \n",
    "            items_in_bin = bin.items \n",
    "            \n",
    "            for ib in items_in_bin: \n",
    "                pivot = [0, 0, 0] \n",
    "                if axis == Axis.LENGTH: # axis = 0/ x-axis\n",
    "                    pivot = [ib.position[0] + ib.get_dimension()[0],\n",
    "                            ib.position[1],\n",
    "                            ib.position[2]]\n",
    "                elif axis == Axis.WIDTH: # axis = 1/ y-axis\n",
    "                    pivot = [ib.position[0],\n",
    "                            ib.position[1] + ib.get_dimension()[1],\n",
    "                            ib.position[2]]\n",
    "                elif axis == Axis.HEIGHT: # axis = 2/ z-axis\n",
    "                    pivot = [ib.position[0],\n",
    "                            ib.position[1],\n",
    "                            ib.position[2] + ib.get_dimension()[2]]\n",
    "        \n",
    "                pivot_list.append(pivot)\n",
    "            \n",
    "        return pivot_list \n",
    "    \n",
    "    def choose_pivot_point(self, bin, item):\n",
    "        \"\"\"Choose the optimal one from all optional pivot points of the item after comparison.\n",
    "        Args:\n",
    "            bin: a bin in bin list that a certain item will be placed into.\n",
    "            item: an unplaced item in item list.\n",
    "        Returns:\n",
    "            the optimal pivot point that a item could be placed into a bin.\n",
    "        \"\"\"\n",
    "        \n",
    "        can_put = False\n",
    "        pivot_available = []\n",
    "        pivot_available_temp = []\n",
    "        vertex_3d = []\n",
    "        vertex_2d = []\n",
    "        vertex_1d = []\n",
    "        \n",
    "        n = 0\n",
    "        m = 0\n",
    "        p = 0\n",
    "        \n",
    "        pivot_list = self.pivot_list(bin, item)\n",
    "        \n",
    "        for pivot in pivot_list:\n",
    "            try_put_item = bin.can_hold_item_with_rotation(item, pivot)\n",
    "            \n",
    "            if try_put_item:\n",
    "                can_put = True\n",
    "                pivot_available.append(pivot)\n",
    "                pivot_temp = sorted(pivot)\n",
    "                pivot_available_temp.append(pivot_temp)\n",
    "        \n",
    "        if pivot_available:\n",
    "            while p < len(pivot_available_temp):\n",
    "                vertex_3d.append(pivot_available_temp[p][0])\n",
    "                p += 1\n",
    "            \n",
    "            p = 0\n",
    "            while p < len(pivot_available_temp): \n",
    "                if pivot_available_temp[p][0] == min(vertex_3d):\n",
    "                    n += 1\n",
    "                    vertex_2d.append(pivot_available_temp[p][1])\n",
    "                \n",
    "                p += 1\n",
    "        \n",
    "            if n == 1:\n",
    "                p = 0\n",
    "                while p < len(pivot_available_temp):\n",
    "                    if pivot_available_temp[p][0] == min(pivot_available_temp[p]):\n",
    "                        return pivot_available[p]\n",
    "                \n",
    "                    p += 1\n",
    "        \n",
    "            else:\n",
    "                p = 0\n",
    "                while p < len(pivot_available_temp):\n",
    "                    if (\n",
    "                        pivot_available_temp[p][0] == min(pivot_available_temp[p]) and \n",
    "                        pivot_available_temp[p][1] == min(vertex_2d)\n",
    "                    ):\n",
    "                        m += 1\n",
    "                        vertex_1d.append(pivot_available_temp[p][2])\n",
    "                \n",
    "                    p += 1\n",
    "        \n",
    "            if m == 1:\n",
    "                p = 0\n",
    "                while p < len(pivot_available_temp):\n",
    "                    if (\n",
    "                        pivot_available_temp[p][0] == min(pivot_available_temp[p]) and \n",
    "                        pivot_available_temp[p][1] == min(vertex_2d)\n",
    "                    ):\n",
    "                        return pivot_available[p]\n",
    "                \n",
    "                    p += 1\n",
    "        \n",
    "            else:\n",
    "                p = 0\n",
    "                while p < len(pivot_available_temp):\n",
    "                    if (\n",
    "                        pivot_available_temp[p][0] == min(pivot_available_temp[p]) and\n",
    "                        pivot_available_temp[p][1] == min(vertex_2d) and\n",
    "                        pivot_available_temp[p][2] == min(vertex_1d)\n",
    "                    ):\n",
    "                        return pivot_available[p]\n",
    "                \n",
    "                    p += 1\n",
    "        \n",
    "        if not pivot_available:\n",
    "            return can_put\n",
    "        \n",
    "    def pack_to_bin(self, bin, item): \n",
    "        \"\"\"For each item and each bin, perform whole pack process with optimal orientation and pivot point.\n",
    "        Args:\n",
    "            bin: a bin in bin list that a certain item will be placed into.\n",
    "            item: an unplaced item in item list.\n",
    "        Returns: return value is void.\n",
    "        \"\"\"\n",
    "        \n",
    "        if not bin.items:\n",
    "            response = bin.put_item(item, START_POSITION, [bin.length, bin.width, bin.height])\n",
    "            \n",
    "            if not response:\n",
    "                bin.unfitted_items.append(item)\n",
    "            \n",
    "            return \n",
    "        \n",
    "        else:\n",
    "            pivot_point = self.choose_pivot_point(bin, item)\n",
    "            pivot_dict = self.pivot_dict(bin, item)\n",
    "                \n",
    "            if not pivot_point:\n",
    "                bin.unfitted_items.append(item)\n",
    "                return \n",
    "                \n",
    "            distance_3D = pivot_dict[tuple(pivot_point)]\n",
    "            response = bin.put_item(item, pivot_point, distance_3D)\n",
    "            return  \n",
    "            \n",
    "    def pack(\n",
    "        self, bigger_first=True, number_of_decimals=DEFAULT_NUMBER_OF_DECIMALS):\n",
    "        \"\"\"For a list of items and a list of bins, perform the whole pack process.\n",
    "        Args:\n",
    "            bin: a bin in bin list that a certain item will be placed into.\n",
    "            item: an unplaced item in item list.\n",
    "        Returns:\n",
    "            For each bin, print detailed information about placed and unplaced items.\n",
    "            Then, print the optimal bin with highest packing rate.\n",
    "        \"\"\"\n",
    "        \n",
    "        for bin in self.bins:\n",
    "            bin.format_numbers(number_of_decimals)\n",
    "            \n",
    "        for unplaced_item in self.unplaced_items:\n",
    "            unplaced_item.format_numbers(number_of_decimals)\n",
    "        \n",
    "        self.bins.sort(\n",
    "            key = lambda bin: bin.get_volume()) # default order of bins: from smallest to biggest\n",
    "        self.unplaced_items.sort(\n",
    "            key = lambda unplaced_item: unplaced_item.get_volume(), reverse=bigger_first) # default order of items: from biggest to smallest\n",
    "        \n",
    "        filling_ratio_list = []\n",
    "        \n",
    "        for bin in self.bins: \n",
    "            for unplaced_item in self.unplaced_items: \n",
    "                bin.unplaced_items.append(unplaced_item) \n",
    "        \n",
    "        for bin in self.bins:\n",
    "            for unplaced_item in self.unplaced_items:\n",
    "                self.pack_to_bin(bin, unplaced_item)\n",
    "                \n",
    "            print(\"\\n:::::::::::\", bin.string())\n",
    "            print(\"FITTED ITEMS:\")\n",
    "            for item in bin.items:\n",
    "                print(\"====> \", item.string())\n",
    "            \n",
    "            print(\"\\nUNFITTED ITEMS:\")\n",
    "            for item in bin.unfitted_items:\n",
    "                print(\"====> \", item.string())\n",
    "            \n",
    "            filling_ratio_list.append(bin.get_filling_ratio())\n",
    "            \n",
    "        max_filling_ratio = max(filling_ratio_list) \n",
    "        \n",
    "        for bin in self.bins:\n",
    "            if bin.get_filling_ratio() == max_filling_ratio: \n",
    "                for item in bin.items:\n",
    "                    self.placed_items.append(item)\n",
    "                print(\"\\nSelected bin with highest filling ratio: \", bin.string())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.6 (tensorflow)",
   "language": "python",
   "name": "tensorflow"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
